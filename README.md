重构：改善既有代码的设计
-----------------------

重构：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。

重构：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。

# Tips
- 如果你发现自己需要为程序添加一个特性，而代码结构使你无法很方便地达成目的，那就先重构那个程序，使特性的添加比较容易进行，然后再添加特性
- 重构的第一步：为即将修改的代码建立一组可靠的测试环境。重构之前，首先检查自己是否有一套可靠的测试机制。这些测试必须有自我检验能力
- 重构技术就是以微小的步伐修改程序。如果你发现错误，很容易便可发现它。
- 任何一个傻瓜都能写出计算机可以理解的代码。唯有写出人类容易理解的代码，才是优秀的程序员。更改变量名称，提高代码清晰度。代码应该表现自己的目的
- 尽量去除一些无意义的临时变量，临时变量往往引发问题，会导致大量参数被传来传去，很容易跟丢它们，尤其在长长的函数中
- 两顶帽子：重构时应该把时间分配给两种行为：添加新功能和重构。添加新功能不能修改既有代码，只添加新功能；重构不能再添加新功能，只管改进程序结构，此时也不应添加任何测试
- 代码结构的流失是累积性的。越难看出代码所代表的设计意图，就越难保护其中的设计
- 消除重复代码：代码越多，正确的修改就越困难
- "准确说出我想要的"
- 重构使代码更容易理解和阅读。重构可以帮助我们写出更强健的代码。重构帮助我们快速地开发程序
- 三次法则：事不过三，三则重构
    - 第一次做某件事时只管去做
    - 第二次做类似的事情就会产生反感，但无论如何还是可以去做
    - 第三次再做类似的事情，就应该重构
- 重构时机：
    - 添加功能时重构
    - 修补错误时重构：如果收到一份错误报告，这就是重构的信号
    - 复审代码时重构
- 难以阅读的代码，难以修改
- 逻辑重复的代码，难以修改
- 添加新行为时需要修改已有代码的程序，难以修改
- 带复杂条件逻辑的程序，难以修改
- 好程序的特性：
    - 容易阅读
    - 所有逻辑都只在唯一地点指定
    - 新的改动不会危及现有行为
    - 尽可能简单表达条件逻辑
- 计算机是这样一门科学：它相信所有问题都可以通过增加一个间接层来解决
    - 间接层是一把双刃剑
    - 允许逻辑共享
    - 分开解释意图和实现
    - 隔离变化
    - 封装条件逻辑
    - 间接层可能导致对象过多
- 重构的难题
    - 数据库：在对象模型和数据库模型之间插入一个分隔层，隔离两个模型各自的变化
    - 修改接口：如何面对那些必须修改"已发布"接口（找不到，即使找到也不能修改的接口）的重构手法？
        - 让旧接口调用新接口。当你要修改某个函数名称时，请留下旧函数，让它调用新函数。**千万不要复制函数实现，它会让你陷入重复代码的泥淖中难以自拔**
        - 除非真有必要，不要发布接口。改版代码所有权政策，让每个人都可以修改别人的代码，以适应接口的改动
- 不要过早发布接口。请修改你的代码所有权政策，使重构更顺畅
- 何时不应该重构
    - 有时候重新编写代码比重构还简单时，就不应该重构。重写而非重构的一个清楚讯号就是：现有代码根本不能正常运作。重构之前，代码必须起码能够在大部分情况下正常运作
    - 将"大块头"重构为良好的小组件，然后可以逐一对组件做出"重构或重建"的决定
    - 项目已近最后期限，应该避免重构
- 重构可以带来更简单的设计，同时又不损失灵活性，这降低了设计过程的难度，减轻了设计压力
- 哪怕你完全了解系统，也请实际度量它的性能，不要臆测。臆测会让你学到一些东西，但十有八九是错的
- 编写快速软件的秘密就是：首先写出可调的软件，然后调整它以求获得足够速度
- 编写快速软件的方法：
    - 时间预算法：给每个组件预先分配一定的资源：时间和执行轨迹
    - 持续关注法：在任何时间做任何事情都要设法保持系统的高性能
    - 利用统计数据：编写程序时不对性能投以特别的关注，直至进入性能优化阶段
- 代码的坏味道
    - 重复代码
        - Extract Method：提炼出重复代码
        - Pull Up Method：将方法推入超类
        - Form Template Method：构建模板方法
        - Substitute Algorithm：替换算法
        - Extract Class：提炼出类
    - 过长函数
        - 让小函数容易理解的关键是有一个好名字
        - 每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其用途（而非实现方法）命名
        - 关键不在于函数的长度，而在于函数"做什么"和"如何做"之间的语义距离
        - Extract Method
        - Replace Temp With Query 消除临时元素
        - Introduce Parameter Object 和 Preserve Whole Object 可以将过长的参数列变得简洁一些
        - Replace Method With Method Object
        - 寻找注释：如果代码前方有一行注释，就是在提醒你可以将这段代码替换为一个函数，而且可以在注释的基础上给这个函数命名。就算只有一行代码，如果需要以注释来说明，那也值得将它提炼到独立的函数中。
        - 条件表达式和循环常常也是提炼的信号，可以使用 Decompose Conditional 处理条件表达式
        - 循环应该将循环和其内部代码提炼到一个独立的函数中
    - 过大的类
        - Extract Class
        - Extract Subclass
        - 先确定客户端如何使用它们，然后运用 Extract Interface 为每一种使用方式提炼出一个接口
        - Duplicate Observed Data
    - 过长参数列
        - 使用对象
        - Replace Parameter with Method
        - Preserve Whole Object：将来自同一个对象的一堆数据收集起来，并以该对象替换它们
        - Introduce Parameter Object：构造参数对象
        - 例外：有时候不希望造成"被调用对象"与"较大对象"间的某种依赖关系，这时候将数据从对象中拆解出来单独作为参数，也是合理的
        - 如果参数列太长或变化太频繁，就需要重新考虑自己的依赖结构了
    - 发散式变化
        - 软件是需要能够容易被修改的，一旦需要修改，我们希望能够跳到系统的某一点，只在该处做修改。如果不能做到这一点，就发现了两种紧密相关的刺鼻味道中的一种了
        - 如果某个类经常因为不同的原因在不同的方向上发生变化，Divergent Change（发散式变化）就出现了
        - 针对某一外界变化的所有相应修改，都只应该发生在单一类中，而这个新类内的所有内容都应该反应此变化
        - 应该找出某特定原因而造成的所有变化，然后运用 Extract Class 将它们提炼到另一个类中
    - 散弹式修改
        - 如果遇到某种变化，你都必须在许多不同的类内做许多小修改，面临的就是散弹式变化（Shotgun Surgery)
        - 使用 Move Method 和 Move Field 把所有需要修改的代码放进同一个类，如果目前没有合适的类可以安置这些代码，就造一个
        - 通常可以运用 Inline Class 把一系列相关行为放进同一个类
        - 发散式变化是指一个类受到多种变化的影响
        - 散弹式变化是指一种变化引发多个类做相应的修改
        - 修改代码，使「外界变化」与「需要修改的类」趋于一一对应
    - 依恋情结（Feature Envy）
        - 函数对某个类的星期高过对自己所处的类的兴趣，这种孺慕之情最通常的焦点便是数据
        - 使用 Move Method 把它移到它该去的地方
        - 使用 Extract Method 把受影响的一部分提炼到独立的函数中，再使用 Move Method 把它移动到特定的类中
        - 如果一个函数使用到了多个类的功能，判断哪个类拥有最多被此函数使用的数据，然后把这个函数和这些数据摆在一起
        - **最根本的原则是：将总是一起变化的东西放在一块儿**。
        - 数据和引用这些数据的行为总是一起变化，但也有例外。如果例外出现，我们就搬移那些行为，保持变化只在一地发生
    - 数据泥团（Data Clumps）
        - 总是绑在一起出现的数据应该拥有自己的对象
        - 首先找出这些数据已字段形式出现的地方，运用 Extract Class 将它们提炼到一个独立的对象中
        - 然后将注意力转移到函数签名上，运用 Introduce Parameter Object 或 Preserve Whole Object 为它减肥
        - 好处：将很多参数列缩短，简化函数调用
        - 不必在意 Data Clumps 只用上新对象的一部分字段，只要以新对象取代两个（或更多）字段，就值回票价了
        - 如果删除一个数据项，其他数据失去意义，则应该为它们产生一个新的对象。得到新对象后，还可以着手寻找依恋情结（Feature Envy），这可以帮你指出可以移至新类中的种种程序行为